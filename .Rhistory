oven.s<-oven
}
# thermogram selection
if (thermogram=="all"){
thermo.s<-c("CH","CO","CO2","SO2")
cross.s<-expand.grid(thermo.s,oven.s)
} else{
thermo.s<-thermogram
cross.s<-expand.grid(thermo.s,oven.s)
}
# Error when impossible combination is made.
if (oven=="Oxidation" & thermogram=="CH"){
stop("A CH pyrogram doesn't exist in the oxidation oven.")
}
# Par
par(mfrow=c(length(oven.s),length(thermo.s)))
# plot RE thermogram data
for (i in 1:nrow(cross.s)) {
# basic plotting
thermo.i<-as.character(cross.s[i,1])
oven.i<-as.character(cross.s[i,2])
plot(plotdata[[oven.i]][["t"]],plotdata[[oven.i]][[thermo.i]],
type="l", lwd=2, col="gray11",
xlab = "Time", ylab="RE Signal")
# determine what cursors to include
curs.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no!=0]
base.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no==0]
select.curs<-plotdata$Cursors[curs.s]
select.base<-plotdata$Cursors[base.s]
# plot cursors and baseline
invisible(mapply(function(curs) abline(v=curs, col="red3"), curs=select.curs))
abline(h=select.base, col="royalblue4")
}
}
etc.
}
#1.1 Get selected data
plotdata<-get(datalist)[[analysis]]
# determine dimensions
# oven selection
if (oven=="both"){
oven.s<-c("Pyrolysis","Oxidation")
} else{
oven.s<-oven
}
# thermogram selection
if (thermogram=="all"){
thermo.s<-c("CH","CO","CO2","SO2")
cross.s<-expand.grid(thermo.s,oven.s)
} else{
thermo.s<-thermogram
cross.s<-expand.grid(thermo.s,oven.s)
}
# Error when impossible combination is made.
if (oven=="Oxidation" & thermogram=="CH"){
stop("A CH pyrogram doesn't exist in the oxidation oven.")
}
# Par
par(mfrow=c(length(oven.s),length(thermo.s)))
# plot RE thermogram data
for (i in 1:nrow(cross.s)) {
# basic plotting
thermo.i<-as.character(cross.s[i,1])
oven.i<-as.character(cross.s[i,2])
plot(plotdata[[oven.i]][["t"]],plotdata[[oven.i]][[thermo.i]],
type="l", lwd=2, col="gray11",
xlab = "Time", ylab="RE Signal")
# determine what cursors to include
curs.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no!=0]
base.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no==0]
select.curs<-plotdata$Cursors[curs.s]
select.base<-plotdata$Cursors[base.s]
# plot cursors and baseline
invisible(mapply(function(curs) abline(v=curs, col="red3"), curs=select.curs))
abline(h=select.base, col="royalblue4")
}
dev.off()
#1.1 Get selected data
plotdata<-get(datalist)[[analysis]]
# determine dimensions
# oven selection
if (oven=="both"){
oven.s<-c("Pyrolysis","Oxidation")
} else{
oven.s<-oven
}
# thermogram selection
if (thermogram=="all"){
thermo.s<-c("CH","CO","CO2","SO2")
cross.s<-expand.grid(thermo.s,oven.s)
} else{
thermo.s<-thermogram
cross.s<-expand.grid(thermo.s,oven.s)
}
# Error when impossible combination is made.
if (oven=="Oxidation" & thermogram=="CH"){
stop("A CH pyrogram doesn't exist in the oxidation oven.")
}
# Par
par(mfrow=c(length(oven.s),length(thermo.s)))
# plot RE thermogram data
for (i in 1:nrow(cross.s)) {
# basic plotting
thermo.i<-as.character(cross.s[i,1])
oven.i<-as.character(cross.s[i,2])
plot(plotdata[[oven.i]][["t"]],plotdata[[oven.i]][[thermo.i]],
type="l", lwd=2, col="gray11",
xlab = "Time", ylab="RE Signal")
# determine what cursors to include
curs.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no!=0]
base.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no==0]
select.curs<-plotdata$Cursors[curs.s]
select.base<-plotdata$Cursors[base.s]
# plot cursors and baseline
invisible(mapply(function(curs) abline(v=curs, col="red3"), curs=select.curs))
abline(h=select.base, col="royalblue4")
}
oven<-"Oxidation"
plotdata<-get(datalist)[[analysis]]
# determine dimensions
# oven selection
if (oven=="both"){
oven.s<-c("Pyrolysis","Oxidation")
} else{
oven.s<-oven
}
# thermogram selection
if (thermogram=="all"){
thermo.s<-c("CH","CO","CO2","SO2")
cross.s<-expand.grid(thermo.s,oven.s)
} else{
thermo.s<-thermogram
cross.s<-expand.grid(thermo.s,oven.s)
}
# Error when impossible combination is made.
if (oven=="Oxidation" & thermogram=="CH"){
stop("A CH pyrogram doesn't exist in the oxidation oven.")
}
# Par
par(mfrow=c(length(oven.s),length(thermo.s)))
# plot RE thermogram data
for (i in 1:nrow(cross.s)) {
# basic plotting
thermo.i<-as.character(cross.s[i,1])
oven.i<-as.character(cross.s[i,2])
plot(plotdata[[oven.i]][["t"]],plotdata[[oven.i]][[thermo.i]],
type="l", lwd=2, col="gray11",
xlab = "Time", ylab="RE Signal")
# determine what cursors to include
curs.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no!=0]
base.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no==0]
select.curs<-plotdata$Cursors[curs.s]
select.base<-plotdata$Cursors[base.s]
# plot cursors and baseline
invisible(mapply(function(curs) abline(v=curs, col="red3"), curs=select.curs))
abline(h=select.base, col="royalblue4")
}
oven<-"both"
thermogram<-"CO2"
#1.1 Get selected data
plotdata<-get(datalist)[[analysis]]
# determine dimensions
# oven selection
if (oven=="both"){
oven.s<-c("Pyrolysis","Oxidation")
} else{
oven.s<-oven
}
# thermogram selection
if (thermogram=="all"){
thermo.s<-c("CH","CO","CO2","SO2")
cross.s<-expand.grid(thermo.s,oven.s)
} else{
thermo.s<-thermogram
cross.s<-expand.grid(thermo.s,oven.s)
}
# Error when impossible combination is made.
if (oven=="Oxidation" & thermogram=="CH"){
stop("A CH pyrogram doesn't exist in the oxidation oven.")
}
# Par
par(mfrow=c(length(oven.s),length(thermo.s)))
# plot RE thermogram data
for (i in 1:nrow(cross.s)) {
# basic plotting
thermo.i<-as.character(cross.s[i,1])
oven.i<-as.character(cross.s[i,2])
plot(plotdata[[oven.i]][["t"]],plotdata[[oven.i]][[thermo.i]],
type="l", lwd=2, col="gray11",
xlab = "Time", ylab="RE Signal")
# determine what cursors to include
curs.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no!=0]
base.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no==0]
select.curs<-plotdata$Cursors[curs.s]
select.base<-plotdata$Cursors[base.s]
# plot cursors and baseline
invisible(mapply(function(curs) abline(v=curs, col="red3"), curs=select.curs))
abline(h=select.base, col="royalblue4")
}
oven<-"Oxidation"
plotdata<-get(datalist)[[analysis]]
# determine dimensions
# oven selection
if (oven=="both"){
oven.s<-c("Pyrolysis","Oxidation")
} else{
oven.s<-oven
}
# thermogram selection
if (thermogram=="all"){
thermo.s<-c("CH","CO","CO2","SO2")
cross.s<-expand.grid(thermo.s,oven.s)
} else{
thermo.s<-thermogram
cross.s<-expand.grid(thermo.s,oven.s)
}
# Error when impossible combination is made.
if (oven=="Oxidation" & thermogram=="CH"){
stop("A CH pyrogram doesn't exist in the oxidation oven.")
}
# Par
par(mfrow=c(length(oven.s),length(thermo.s)))
# plot RE thermogram data
for (i in 1:nrow(cross.s)) {
# basic plotting
thermo.i<-as.character(cross.s[i,1])
oven.i<-as.character(cross.s[i,2])
plot(plotdata[[oven.i]][["t"]],plotdata[[oven.i]][[thermo.i]],
type="l", lwd=2, col="gray11",
xlab = "Time", ylab="RE Signal")
# determine what cursors to include
curs.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no!=0]
base.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no==0]
select.curs<-plotdata$Cursors[curs.s]
select.base<-plotdata$Cursors[base.s]
# plot cursors and baseline
invisible(mapply(function(curs) abline(v=curs, col="red3"), curs=select.curs))
abline(h=select.base, col="royalblue4")
}
oven<-"Oxiadation"
#1.1 Get selected data
plotdata<-get(datalist)[[analysis]]
# determine dimensions
# oven selection
if (oven=="both"){
oven.s<-c("Pyrolysis","Oxidation")
} else{
oven.s<-oven
}
# thermogram selection
if (thermogram=="all"){
thermo.s<-c("CH","CO","CO2","SO2")
cross.s<-expand.grid(thermo.s,oven.s)
} else{
thermo.s<-thermogram
cross.s<-expand.grid(thermo.s,oven.s)
}
# Error when impossible combination is made.
if (oven=="Oxidation" & thermogram=="CH"){
stop("A CH pyrogram doesn't exist in the oxidation oven.")
}
# Par
par(mfrow=c(length(oven.s),length(thermo.s)))
# plot RE thermogram data
for (i in 1:nrow(cross.s)) {
# basic plotting
thermo.i<-as.character(cross.s[i,1])
oven.i<-as.character(cross.s[i,2])
plot(plotdata[[oven.i]][["t"]],plotdata[[oven.i]][[thermo.i]],
type="l", lwd=2, col="gray11",
xlab = "Time", ylab="RE Signal")
# determine what cursors to include
curs.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no!=0]
base.s<-cursLU$curs[cursLU$oven %in% oven.i & cursLU$thermo %in% thermo.i & cursLU$no==0]
select.curs<-plotdata$Cursors[curs.s]
select.base<-plotdata$Cursors[base.s]
# plot cursors and baseline
invisible(mapply(function(curs) abline(v=curs, col="red3"), curs=select.curs))
abline(h=select.base, col="royalblue4")
}
oven %in% c("both","Pyrolysis","Oxidation")
oven<-"Oxidation"
oven %in% c("both","Pyrolysis","Oxidation")
!(oven %in% c("both","Pyrolysis","Oxidation"))
rm(list=ls())
devtools::load_all()
dataloc<-"D:/PhD/Rock-Eval/Maarten_2501 - Copy/BULK ROCK"
test<-RE_read(dataloc)
select<-S_2501_0035.B00
select<-"S_2501_0035.B00"
RE_plot(test,select)
devtools::load_all()
dataloc<-"D:/PhD/Rock-Eval/Maarten_2501 - Copy/BULK ROCK"
test<-RE_read(dataloc)
select<-"S_2501_0035.B00"
RE_plot(test,select)
RE_plot(test,select,"both","all")
RE_plot(test,select,"dfds","all")
RE_plot(test,select,"Pyrolysis","Oxidation")
RE_plot(test,select,"Pyrolysis","CO2")
RE_plot(test,"S_2501_0035.B00","Pyrolysis","CO2")
RE_plot(test,S_2501_0035.B00,"Pyrolysis","CO2")
devtools::document()
devtools::load_all()
RE_plot(test,"S_2501_0035.B00",pyrogram="CO2")
RE_plot(test,"S_2501_0035.B00",thermogram="CO2")
rm(list=ls())
set.seed(1)
n <- 1e5
time <- seq(0, 1000, length.out = n)
values <- sin(time)
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
?diff()
?head()
(head(values, -1)
(head(values, -1)
)
)
head(values, -1)
head(values, 1)
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
library(pracma)
# pracma
install.packages(pracma)
# pracma
install.packages("pracma")
# pracma
library(pracma)
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
time <- seq(0, 50, length.out = n)
n <- 50
time <- seq(0, 100, length.out = n)
values <- sin(time)
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
n <- 10
time <- seq(0, 100, length.out = n)
values <- sin(time)
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
plot(time,values)
plot(time,values,type="l")
n <- 100
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
n <- 1000
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
n <- 100
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
diff<-integral_manual-integral_pracma
n <- 1000
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
diff<-integral_manual-integral_pracma
n <- 50
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
n <- 70
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
diff<-integral_manual-integral_pracma
n <- 1e5
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
diff<-integral_manual-integral_pracma
n <- 1e7
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
diff<-integral_manual-integral_pracma
n <- 1e6
time <- seq(0, 100, length.out = n)
values <- sin(time)
plot(time,values,type="l")
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
diff<-integral_manual-integral_pracma
n <- 1e7
time <- seq(0, 100, length.out = n)
values <- sin(time)
# Manual
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
# pracma
system.time({
integral_pracma <- trapz(time, values)
})
diff<-integral_manual-integral_pracma
?diff()
?diff()
RE_traparea<-function(x,y){
# Area is calculated manually (alternatives did not perform better).
#1.1 Determine time steps
dx<-diff(x)
#1.2 Determine mean values between each step
my<-(head(y, -1) + tail(y, -1)) / 2
#1.3 Integral is approximated by the sum of (y_n + y_n+1)/2 x dx
area<-sum(my*dx)
area
}
RE_traparea(dt,avg_height)
integral_manual <- sum(dt * avg_height)
RE_traparea(time,values)
my<-RE_traparea(time,values)
system.time({
my<-RE_traparea(time,values)
})
system.time({
dt <- diff(time)
avg_height <- (head(values, -1) + tail(values, -1)) / 2
integral_manual <- sum(dt * avg_height)
})
